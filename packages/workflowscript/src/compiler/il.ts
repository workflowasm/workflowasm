// Intermediate assembly language
import {
  Opcode,
  type AnyVal,
  Type,
  type AsmProgram,
  type ConstantTable,
  dumpValue,
  type MapKey
} from "@workflowasm/protocols-js"

export class FunctionDefinition {
  semver: string
  name: string
  /** IL for the function, generated by first compiler stage. */
  program?: ILProgram
  /** WFASM for the function. (Only valid after compile.) */
  asm?: AsmProgram
  /** Constant table for the function. (Only valid after all compiler stages are complete.) */
  ktable?: ConstantTable

  constructor(name: string, semver: string) {
    this.name = name
    this.semver = semver
  }

  compile() {
    if (this.program === undefined)
      throw new Error(
        "INTERNAL ERROR: compile() called on function with no program"
      )
    Object.assign(this, new ILCompiler(this.program).compile())
  }
}

export enum ILOpcode {
  /** No operation */
  NOOP = 0,
  /** Verbatim WorkflowASM. arg1 = WFASM opcode, arg2 = numeric oparg */
  ASM = 1,
  /** Push literal. arg1 = literal */
  PUSHLITERAL = 2,
  /** Push named function. arg1 = function specification */
  PUSHFN = 3,
  /** Label the next line of ASM */
  LABEL = 4,
  /** JMP to a label */
  GOTO = 5,
  /** Introduce a scope */
  OPEN_SCOPE = 6,
  /** Close a scope */
  CLOSE_SCOPE = 7,
  /** Destructure an object */
  DESTRUCTURE_OBJECT = 8,
  /** Destructure an array */
  DESTRUCTURE_ARRAY = 9,
  /** Normalize function arguments */
  NORMALIZE_ARGS = 10
}

export type ILFn = {
  name: string
  package: string
  semver: string
}

export type ILDestructureObject = {
  /** Sequence of keys to extract from the object in stack order */
  keys: MapKey[]
  /** If true, leave the rest of the keys on the stack as a Map. */
  rest: boolean
}

export type ILDestructureArray = {
  /** Number of entries to pull from front of the array */
  n: number
  /** If true, pushes the remaining elements as a List */
  rest: boolean
}

export type ILNormalizeArgs = {
  /** Number of expected args to function */
  n: number
  /** If true, collects excess arguments beyond `n` into an array */
  rest: boolean
}

export type ILInstruction =
  | [ILOpcode.NOOP, null, null]
  | [ILOpcode.ASM, Opcode, number]
  | [ILOpcode.PUSHLITERAL, AnyVal, null]
  | [ILOpcode.PUSHFN, ILFn, null]
  | [ILOpcode.LABEL, string, null]
  | [ILOpcode.GOTO, string, null]
  | [ILOpcode.OPEN_SCOPE, string, null]
  | [ILOpcode.CLOSE_SCOPE, string, null]
  | [ILOpcode.DESTRUCTURE_OBJECT, ILDestructureObject]
  | [ILOpcode.DESTRUCTURE_ARRAY, ILDestructureArray]
  | [ILOpcode.NORMALIZE_ARGS, ILNormalizeArgs]

export type ILProgram = ILInstruction[]

export const builtinMap: { [key: string]: string } = {
  "lang.int64": "int64",
  "lang.uint64": "uint64",
  "lang.double": "double",
  "lang.bool": "bool",
  "lang.string": "string",
  "lang.len": "len"
}

/** Convenience method for generating IL. */
export function il(...progs: Array<ILProgram | ILInstruction>): ILProgram {
  let instrs: ILProgram = []
  for (const prog of progs) {
    if (Array.isArray(prog[0])) {
      // `prog` is an ILProgram
      instrs = instrs.concat(prog)
    } else if (prog.length > 0) {
      // `prog` is an ILInstruction
      instrs.push(prog as ILInstruction)
    }
  }

  return instrs
}

export function dumpInstruction(instr: ILInstruction): string {
  switch (instr[0]) {
    case ILOpcode.NOOP:
      return "[NOOP]"
    case ILOpcode.ASM:
      return `[${Opcode[instr[1]]}, ${instr[2]}]`
    case ILOpcode.PUSHLITERAL:
      return `PUSHLITERAL ${Type[instr[1][0]]} ${dumpValue(instr[1])}`
    case ILOpcode.PUSHFN:
      return `PUSHFN ${instr[1].name} v'${instr[1].semver}' from '${instr[1].package}'`
    case ILOpcode.LABEL:
      return `  ${instr[1]}:`
    case ILOpcode.GOTO:
      return `GOTO ${instr[1]}`
    case ILOpcode.OPEN_SCOPE:
      return `OPEN_SCOPE ${instr[1]}`
    case ILOpcode.CLOSE_SCOPE:
      return `CLOSE_SCOPE ${instr[1]}`
    case ILOpcode.DESTRUCTURE_OBJECT:
      return `DESTRUCTURE_OBJECT ${instr[1].keys.join(",")}${
        instr[1].rest ? ",..." : ""
      }`
    case ILOpcode.DESTRUCTURE_ARRAY:
      return `DESTRUCTURE_ARRAY ${instr[1].n}${instr[1].rest ? ",..." : ""}`
    case ILOpcode.NORMALIZE_ARGS:
      return `NORMALIZE_ARGS ${instr[1].n}${instr[1].rest ? ",..." : ""}`
  }
}

export function dumpIL(il: ILProgram, prefix: string = ""): string {
  return prefix + il.map(dumpInstruction).join("\n" + prefix)
}

function abs(n: bigint) {
  return n < 0 ? -n : n
}

export class ILCompiler {
  /** IL to be compiled */
  prog: ILProgram
  /** Map from already-seen constants to ktable entries */
  constantDedupe: Map<string | bigint | number, number> = new Map()
  /** ktable */
  constants: ConstantTable = []
  /** Label jump map */
  labels: Map<string, number> = new Map()
  /** Gotos that precede their labels. Points to instruction that needs to be filled with address of label */
  anticipatedLabels: Map<string, number[]> = new Map()
  /** Assembly instructions */
  asm: AsmProgram = []

  constructor(prog: ILProgram) {
    this.prog = prog
  }

  pushLiteral(literal: AnyVal) {
    const [type, val] = literal
    // Handle simple literals
    if (type === Type.NULL) {
      this.asm.push([Opcode.OP_PUSHNULL, 0])
      return
    } else if (type === Type.BOOL) {
      this.asm.push([Opcode.OP_PUSHBOOL, val ? 1 : 0])
    } else if (type === Type.INT64 && abs(val) < Number.MAX_SAFE_INTEGER) {
      this.asm.push([Opcode.OP_PUSHINT, Number(val)])
      return
    }
    // Handle deduplicated literals
    if (
      type === Type.STRING ||
      type === Type.INT64 ||
      type === Type.UINT64 ||
      type === Type.DOUBLE
    ) {
      // Dedupe from existing table entry
      if (this.constantDedupe.has(val)) {
        this.asm.push([Opcode.OP_PUSHK, this.constantDedupe.get(val) as number])
        return
      } else {
        // register in table
        this.constantDedupe.set(val, this.constants.length)
        // fallthrough to general case
      }
    }
    // General case, add to constant table and PUSHK
    this.constants.push(literal)
    this.asm.push([Opcode.OP_PUSHK, this.constants.length - 1])
  }

  pushMapKey(name: MapKey) {
    switch (typeof name) {
      case "string":
        this.pushLiteral([Type.STRING, name])
        break
      case "bigint":
        this.pushLiteral([Type.INT64, name])
        break
      case "boolean":
        this.pushLiteral([Type.BOOL, name])
        break
      default:
        throw new Error(
          "INTERNAL COMPILER ERROR: pushMapKey got unrecognized arg type"
        )
    }
  }

  pushFn(fn: ILFn) {
    this.constants.push([
      Type.CALLABLE,
      { package: fn.package, id: fn.name, semver: fn.semver }
    ])
  }

  label(label: string) {
    const labelAddr = this.asm.length
    this.labels.set(label, labelAddr)
    const anticipated = this.anticipatedLabels.get(label)
    if (anticipated !== undefined) {
      // If a previous goto anticipated this label, rewrite the JMP instr
      // with the now-known address.
      for (const instrPointer of anticipated) {
        this.asm[instrPointer][1] = labelAddr
      }
      this.anticipatedLabels.delete(label)
    }
  }

  goto(label: string) {
    const destination = this.labels.get(label)
    if (destination === undefined) {
      // Going to a label that doesn't exist yet. Record it as an
      // "anticipated" label and create a stub jump instr to be modified
      // later.
      this.asm.push([Opcode.OP_JMP, 0])
      this.anticipatedLabels.set(
        label,
        (this.anticipatedLabels.get(label) ?? []).concat([this.asm.length - 1])
      )
    } else {
      this.asm.push([Opcode.OP_JMP, destination])
    }
  }

  destructureArray(arg: ILDestructureArray) {
    // Index leading segment of array
    for (let i = 0; i < arg.n; i++) {
      this.asm.push([Opcode.OP_DUP, i])
      this.asm.push([Opcode.OP_PUSHINT, i])
      this.asm.push([Opcode.OP_INDEX, 0])
    }
    // If there is a rest element, collect trailing segment
    if (arg.rest) {
      this.asm.push([Opcode.OP_DUP, arg.n])
      this.asm.push([Opcode.OP_PUSHINT, arg.n])
      this.asm.push([Opcode.OP_LREST, 0])
    }
    // Drop the original array
    this.asm.push([Opcode.OP_DROP, arg.rest ? arg.n + 1 : arg.n])
  }

  destructureObject(arg: ILDestructureObject) {
    const n = arg.keys.length
    // Index named keys
    for (const [i, k] of arg.keys.entries()) {
      this.asm.push([Opcode.OP_DUP, i])
      this.pushMapKey(k)
      this.asm.push([Opcode.OP_INDEX, 0])
    }
    // Compose rest map if needed
    if (arg.rest) {
      this.asm.push([Opcode.OP_DUP, n])
      for (const k of arg.keys) this.pushMapKey(k)
      this.pushLiteral([Type.INT64, BigInt(n)])
      this.asm.push([Opcode.OP_OREST, 0])
    }
    // Drop the original object
    this.asm.push([Opcode.OP_DROP, arg.rest ? n + 1 : n])
  }

  normalizeArgs(arg: ILNormalizeArgs) {}

  compile(): { asm: AsmProgram; ktable: ConstantTable } {
    let prog = this.prog

    // If program ends with a label, append a no-op so goto has
    // a valid destination
    if (prog[prog.length - 1][0] === ILOpcode.LABEL) {
      prog = prog.concat([[ILOpcode.NOOP, null, null]])
    }

    for (const instr of prog) {
      switch (instr[0]) {
        case ILOpcode.NOOP:
          this.asm.push([Opcode.OP_NOOP, 0])
          break
        case ILOpcode.ASM:
          this.asm.push([instr[1], instr[2]])
          break
        case ILOpcode.PUSHLITERAL:
          this.pushLiteral(instr[1])
          break
        case ILOpcode.PUSHFN:
          this.pushFn(instr[1])
          break
        case ILOpcode.LABEL:
          this.label(instr[1])
          break
        case ILOpcode.GOTO:
          this.goto(instr[1])
          break
        case ILOpcode.OPEN_SCOPE:
          this.asm.push([Opcode.OP_ENVPUSH, 0])
          break
        case ILOpcode.CLOSE_SCOPE:
          this.asm.push([Opcode.OP_ENVPOP, 0])
          break
        case ILOpcode.DESTRUCTURE_ARRAY:
          this.destructureArray(instr[1])
          break
        case ILOpcode.DESTRUCTURE_OBJECT:
          this.destructureObject(instr[1])
          break
        case ILOpcode.NORMALIZE_ARGS:
          this.normalizeArgs(instr[1])
          break
      }
    }
    return { asm: this.asm, ktable: this.constants }
  }
}
