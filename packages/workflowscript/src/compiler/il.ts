// Intermediate assembly language
import {
  Opcode,
  type AnyVal,
  Type,
  CallableType,
  type AsmProgram,
  type ConstantTable,
  dumpValue
} from "@workflowasm/protocols-js"

export class FunctionDefinition {
  semver: string
  name: string
  /** IL for the function, generated by first compiler stage. */
  program?: ILProgram
  /** WFASM for the function. (Only valid after compile.) */
  asm?: AsmProgram
  /** Constant table for the function. (Only valid after all compiler stages are complete.) */
  ktable?: ConstantTable

  constructor(name: string, semver: string) {
    this.name = name
    this.semver = semver
  }

  compile() {
    if (this.program === undefined)
      throw new Error(
        "INTERNAL ERROR: compile() called on function with no program"
      )
    Object.assign(this, new ILCompiler(this.program).compile())
  }
}

export enum ILOpcode {
  /** No operation */
  NOOP = 0,
  /** Verbatim WorkflowASM. arg1 = WFASM opcode, arg2 = numeric oparg */
  WFASM = 1,
  /** Push literal. arg1 = literal */
  PUSHLITERAL = 2,
  /** Push named function. arg1 = function specification */
  PUSHFN = 3,
  /** Label the next line of ASM */
  LABEL = 4,
  /** JMP to a label */
  GOTO = 5,
  /** Introduce a scope */
  OPEN_SCOPE = 6,
  /** Close a scope */
  CLOSE_SCOPE = 7
}

export type ILFn = {
  name: string
  package: string
  semver: string
}

export type ILInstruction =
  | [ILOpcode.NOOP, null, null]
  | [ILOpcode.WFASM, Opcode, number]
  | [ILOpcode.PUSHLITERAL, AnyVal, null]
  | [ILOpcode.PUSHFN, ILFn, null]
  | [ILOpcode.LABEL, string, null]
  | [ILOpcode.GOTO, string, null]
  | [ILOpcode.OPEN_SCOPE, string, null]
  | [ILOpcode.CLOSE_SCOPE, string, null]

export type ILProgram = ILInstruction[]

export const builtinMap: { [key: string]: string } = {
  "lang.int64": "int64",
  "lang.uint64": "uint64",
  "lang.double": "double",
  "lang.bool": "bool",
  "lang.string": "string",
  "lang.len": "len"
}

/** Convenience method for generating IL. */
export function il(...progs: Array<ILProgram | ILInstruction>): ILProgram {
  let instrs: ILProgram = []
  for (const prog of progs) {
    if (Array.isArray(prog[0])) {
      // `prog` is an ILProgram
      instrs = instrs.concat(prog)
    } else if (prog.length > 0) {
      // `prog` is an ILInstruction
      instrs.push(prog as ILInstruction)
    }
  }

  return instrs
}

export function dumpInstruction(instr: ILInstruction): string {
  switch (instr[0]) {
    case ILOpcode.NOOP:
      return "[NOOP]"
    case ILOpcode.WFASM:
      return `[${Opcode[instr[1]]}, ${instr[2]}]`
    case ILOpcode.PUSHLITERAL:
      return `PUSHLITERAL ${Type[instr[1][0]]} ${dumpValue(instr[1])}`
    case ILOpcode.PUSHFN:
      return `PUSHFN ${instr[1].name} v'${instr[1].semver}' from '${instr[1].package}'`
    case ILOpcode.LABEL:
      return `  ${instr[1]}:`
    case ILOpcode.GOTO:
      return `GOTO ${instr[1]}`
    case ILOpcode.OPEN_SCOPE:
      return `OPEN_SCOPE ${instr[1]}`
    case ILOpcode.CLOSE_SCOPE:
      return `CLOSE_SCOPE ${instr[1]}`
  }
}

export function dumpIL(il: ILProgram, prefix: string = ""): string {
  return prefix + il.map(dumpInstruction).join("\n" + prefix)
}

function abs(n: bigint) {
  return n < 0 ? -n : n
}

export class ILCompiler {
  /** IL to be compiled */
  prog: ILProgram
  /** Map from already-seen constants to ktable entries */
  constantDedupe: Map<string | bigint | number, number> = new Map()
  /** ktable */
  constants: ConstantTable = []
  /** Label jump map */
  labels: Map<string, number> = new Map()
  /** Gotos that precede their labels. Points to instruction that needs to be filled with address of label */
  anticipatedLabels: Map<string, number[]> = new Map()
  /** Assembly instructions */
  asm: AsmProgram = []

  constructor(prog: ILProgram) {
    this.prog = prog
  }

  pushLiteral(literal: AnyVal) {
    const [type, val] = literal
    // Handle simple literals
    if (type === Type.NULL) {
      this.asm.push([Opcode.OP_PUSHNULL, 0])
      return
    } else if (type === Type.INT64 && abs(val) < Number.MAX_SAFE_INTEGER) {
      this.asm.push([Opcode.OP_PUSHINT, Number(val)])
      return
    }
    // Handle deduplicated literals
    if (
      type === Type.STRING ||
      type === Type.INT64 ||
      type === Type.UINT64 ||
      type === Type.DOUBLE
    ) {
      // Dedupe from existing table entry
      if (this.constantDedupe.has(val)) {
        this.asm.push([Opcode.OP_PUSHK, this.constantDedupe.get(val) as number])
        return
      } else {
        // register in table
        this.constantDedupe.set(val, this.constants.length)
        // fallthrough to general case
      }
    }
    // General case, add to constant table and PUSHK
    this.constants.push(literal)
    this.asm.push([Opcode.OP_PUSHK, this.constants.length - 1])
  }

  pushFn(fn: ILFn) {
    const fqn = fn.package + "." + fn.name
    if (builtinMap[fqn]) {
      this.constants.push([
        Type.CALLABLE,
        { type: CallableType.NATIVE, id: builtinMap[fqn] }
      ])
    }
  }

  label(label: string) {
    const labelAddr = this.asm.length
    this.labels.set(label, labelAddr)
    const anticipated = this.anticipatedLabels.get(label)
    if (anticipated !== undefined) {
      // If a previous goto anticipated this label, rewrite the JMP instr
      // with the now-known address.
      for (const instrPointer of anticipated) {
        this.asm[instrPointer][1] = labelAddr
      }
      this.anticipatedLabels.delete(label)
    }
  }

  goto(label: string) {
    const destination = this.labels.get(label)
    if (destination === undefined) {
      // Going to a label that doesn't exist yet. Record it as an
      // "anticipated" label and create a stub jump instr to be modified
      // later.
      this.asm.push([Opcode.OP_JMP, 0])
      this.anticipatedLabels.set(
        label,
        (this.anticipatedLabels.get(label) ?? []).concat([this.asm.length - 1])
      )
    } else {
      this.asm.push([Opcode.OP_JMP, destination])
    }
  }

  compile(): { asm: AsmProgram; ktable: ConstantTable } {
    let prog = this.prog

    // If program ends with a label, append a no-op so goto has
    // a valid destination
    if (prog[prog.length - 1][0] === ILOpcode.LABEL) {
      prog = prog.concat([[ILOpcode.NOOP, null, null]])
    }

    for (const instr of prog) {
      switch (instr[0]) {
        case ILOpcode.NOOP:
          this.asm.push([Opcode.OP_NOOP, 0])
          break
        case ILOpcode.WFASM:
          this.asm.push([instr[1], instr[2]])
          break
        case ILOpcode.PUSHLITERAL:
          this.pushLiteral(instr[1])
          break
        case ILOpcode.PUSHFN:
          this.pushFn(instr[1])
          break
        case ILOpcode.LABEL:
          this.label(instr[1])
          break
        case ILOpcode.GOTO:
          this.goto(instr[1])
          break
        case ILOpcode.OPEN_SCOPE:
          this.asm.push([Opcode.OP_ENVPUSH, 0])
          break
        case ILOpcode.CLOSE_SCOPE:
          this.asm.push([Opcode.OP_ENVPOP, 0])
          break
      }
    }
    return { asm: this.asm, ktable: this.constants }
  }
}
