// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file workflowasm/lang/v1/instruction.proto (package workflowasm.lang.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Opcodes for WorkflowASM instructions.
 *
 * @generated from enum workflowasm.lang.v1.Opcode
 */
export enum Opcode {
  /**
   * No-op instruction. Execution proceeds without any effect.
   *
   * @generated from enum value: OP_NOOP = 0;
   */
  OP_NOOP = 0,

  /**
   * Halt instruction. Terminates execution immediately. HALT
   * may return a Status and a Result to the runtime, which in the best case
   * will be recorded by the controller as the result of the run.
   *
   * @generated from enum value: OP_HALT = 1;
   */
  OP_HALT = 1,

  /**
   * Push a value from the function's constant table to the top of the
   * value stack.
   *
   * `i1`: Index into the constant table of the constant to push.
   *
   * @generated from enum value: OP_PUSHK = 2;
   */
  OP_PUSHK = 2,

  /**
   * Push the result of evaluating a CEL expression from the function's
   * expr table to the top of the value stack.
   *
   * `i1`: Index into the expression table of the expression to evaluate.
   *
   * @generated from enum value: OP_PUSHX = 3;
   */
  OP_PUSHX = 3,

  /**
   * Push a state variable at the given callstack level to the top of the
   * value stack.
   *
   * `i1`: Index of the callstack level to access.
   * `name`: Name of the variable whose value to push.
   *
   * @generated from enum value: OP_PUSHV = 4;
   */
  OP_PUSHV = 4,

  /**
   * Pop `i1` values from the top of the stack, discarding them
   *
   * `i1`: Number of values to pop.
   *
   * @generated from enum value: OP_POP = 5;
   */
  OP_POP = 5,

  /**
   * Sets the named state variable at the given callstack level to a value
   * from the value stack.
   *
   * `i1`: Position on value stack of value to be set
   * `i2`: Level of call stack to set
   * `name`: Name of variable to set
   *
   * @generated from enum value: OP_SET = 6;
   */
  OP_SET = 6,

  /**
   * Removes the named state variable at the given callstack level from
   * the state.
   *
   * `i1`: Ignored
   * `i2`: Level of call stack to clear
   * `name`: Name of variable to clear
   *
   * @generated from enum value: OP_CLEAR = 7;
   */
  OP_CLEAR = 7,

  /**
   * Computes the Boolean equivalent of the value at `i1`. If the result
   * is TRUE, the next instruction in the code segment is executed. If the
   * result is FALSE, the next instruction in the code segment is skipped.
   *
   * `i1`: Stack position of value to examine
   * `i2`: Flags. If flags = 0, proceed as above. If flags != 0, the Boolean
   * condition is negated.
   *
   * @generated from enum value: OP_IF = 8;
   */
  OP_IF = 8,

  /**
   * Jump instruction. Moves the instruction pointer to another index within the
   * currently-executing code segment.
   *
   * `i1`: Stack position of a numerical value for where to jump.
   * `i2`: Flags. If flags = 0, the jump is absolute. If flags != 0, the jump
   * is measured relative to the current instruction pointer.
   *
   * Error conditions:
   *  Expression doesn't evaluate to an integer:
   *  Integer is out of bounds of code segment:
   *
   * @generated from enum value: OP_JMP = 9;
   */
  OP_JMP = 9,

  /**
   * Store the current instruction pointer on the call stack, then jump to the
   * entry point of another named function.
   *
   * `i1`: Count of values on the value stack, measured from the top, for
   * arguments to pass to the function.
   * `name`: Name of function to call.
   *
   * @generated from enum value: OP_CALL = 10;
   */
  OP_CALL = 10,

  /**
   * Return to the function/instruction atop the call stack
   *
   * @generated from enum value: OP_RETURN = 11;
   */
  OP_RETURN = 11,

  /**
   * Persist the current state, which should be a "known good" state, to the
   * controller responsible for this workflow run.
   * Execution is always suspended until the responsible
   * controller confirms that the checkpoint has been persisted.
   *
   * @generated from enum value: OP_CHECKPOINT = 12;
   */
  OP_CHECKPOINT = 12,

  /**
   * Execute an action (driver-defined, usually an RPC call) leaving a
   * `google.rpc.Status` object at the top of the stack 
   *
   * @generated from enum value: OP_ACTION = 13;
   */
  OP_ACTION = 13,
}
// Retrieve enum metadata with: proto3.getEnumType(Opcode)
proto3.util.setEnumType(Opcode, "workflowasm.lang.v1.Opcode", [
  { no: 0, name: "OP_NOOP" },
  { no: 1, name: "OP_HALT" },
  { no: 2, name: "OP_PUSHK" },
  { no: 3, name: "OP_PUSHX" },
  { no: 4, name: "OP_PUSHV" },
  { no: 5, name: "OP_POP" },
  { no: 6, name: "OP_SET" },
  { no: 7, name: "OP_CLEAR" },
  { no: 8, name: "OP_IF" },
  { no: 9, name: "OP_JMP" },
  { no: 10, name: "OP_CALL" },
  { no: 11, name: "OP_RETURN" },
  { no: 12, name: "OP_CHECKPOINT" },
  { no: 13, name: "OP_ACTION" },
]);

/**
 * A single instruction in a WorkflowASM program.
 *
 * @generated from message workflowasm.lang.v1.Instruction
 */
export class Instruction extends Message<Instruction> {
  /**
   * Opcode for the instruction
   *
   * @generated from field: workflowasm.lang.v1.Opcode opcode = 1;
   */
  opcode = Opcode.OP_NOOP;

  /**
   * Integer parameter 1. Interpretation of this parameter depends on the
   * opcode.
   *
   * @generated from field: int32 i1 = 2;
   */
  i1 = 0;

  /**
   * Integer parameter 2. Interpretation of this parameter depends on the
   * opcode.
   *
   * @generated from field: int32 i2 = 3;
   */
  i2 = 0;

  /**
   * For opcodes that act on named objects, the name of the object
   * to act on.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  constructor(data?: PartialMessage<Instruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "workflowasm.lang.v1.Instruction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "opcode", kind: "enum", T: proto3.getEnumType(Opcode) },
    { no: 2, name: "i1", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "i2", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Instruction {
    return new Instruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Instruction {
    return new Instruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Instruction {
    return new Instruction().fromJsonString(jsonString, options);
  }

  static equals(a: Instruction | PlainMessage<Instruction> | undefined, b: Instruction | PlainMessage<Instruction> | undefined): boolean {
    return proto3.util.equals(Instruction, a, b);
  }
}

