// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file workflowasm/lang/v1/instruction.proto (package workflowasm.lang.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Opcodes for WorkflowASM instructions.
 *
 * @generated from enum workflowasm.lang.v1.Opcode
 */
export enum Opcode {
  /**
   * No-op instruction. Execution proceeds without any effect.
   *
   * @generated from enum value: OP_NOOP = 0;
   */
  OP_NOOP = 0,

  /**
   * Push `null` to the stack.
   *
   * Stack signature: `[1]`
   *
   * @generated from enum value: OP_PUSHNULL = 1;
   */
  OP_PUSHNULL = 1,

  /**
   * Push the constant integer value given by `i1` to the stack.
   *
   * `i1`: The literal constant to push.
   *
   * Stack signature: `[1]`
   *
   * @generated from enum value: OP_PUSHINT = 2;
   */
  OP_PUSHINT = 2,

  /**
   * Push the depth of the stack (as an int64) to the stack. (Note that
   * the result left by this opcode is not counted in the stack depth.)
   *
   * Stack signature: `[1]`
   *
   * @generated from enum value: OP_PUSHDEPTH = 3;
   */
  OP_PUSHDEPTH = 3,

  /**
   * Push a value from the function's constant table to the top of the
   * value stack.
   *
   * `i1`: Index into the constant table of the constant to push.
   *
   * Stack signature: `[1]`
   *
   * Throws:
   * * `google.rpc.Code.OUT_OF_RANGE` if no such index exists in
   * the constant table.
   *
   * @generated from enum value: OP_PUSHK = 4;
   */
  OP_PUSHK = 4,

  /**
   * Compute `stack(0)[stack(-1)]` and push its value.
   *
   * Stack signature: `[-2, 1]`
   *
   * Throws:
   * * `google.rpc.Code.INVALID_ARGUMENT` if `stack(0)` is not indexable
   * * `google.rpc.Code.OUT_OF_RANGE` if no such index exists in `stack(0)`
   * * `google.rpc.Code.FAILED_PRECONDITION` if `depth < 2`
   *
   * @generated from enum value: OP_PUSHINDEX = 5;
   */
  OP_PUSHINDEX = 5,

  /**
   * Compute `env[stack(0)]` and push its value. `env` is either the
   * local or global environment depending on `i1`.
   *
   * `i1`: If 0, use the function's local environment, falling back to global
   * if the variable is unset. If 1, use the local environment with no
   * fallback. If 2, use the global environment.
   *
   * Stack signature: `[-1, 1]`
   *
   * Throws:
   * * `google.rpc.Code.OUT_OF_RANGE` if no such index exists in `env`
   * * `google.rpc.Code.FAILED_PRECONDITION` if `depth < 1`
   *
   * @generated from enum value: OP_PUSHENV = 6;
   */
  OP_PUSHENV = 6,

  /**
   * Duplicate the value at `stack(i1)` and push it. For non-primitive values,
   * this is a deep duplication. Nothing is removed from the stack.
   *
   * `i1`: Stack index to duplicate.
   *
   * Stack signature: `[1]`
   *
   * Throws:
   * * `google.rpc.Code.INVALID_ARGUMENT` if the value cannot be duplicated.
   * * `google.rpc.Code.FAILED_PRECONDITION` if `i1` is an invalid stack index.
   *
   * @generated from enum value: OP_DUP = 7;
   */
  OP_DUP = 7,

  /**
   * Pop `i1` values from the top of the stack, discarding them
   *
   * `i1`: Number of values to pop. If `0` is given, 1 value will still be
   * popped.
   *
   * Stack signature: `[-i1]`
   *
   * Throws:
   * * `google.rpc.Code.FAILED_PRECONDITION` if `depth < i1`
   *
   * @generated from enum value: OP_POP = 8;
   */
  OP_POP = 8,

  /**
   * Roll the top `i1` values on the stack. Effectively, moves the object
   * at `stack(-i1 + 1)` to the top of the stack.
   *
   * `i1`: Number of stack entries to roll.
   *
   * Stack signature: `[]`
   *
   * Throws:
   * * `google.rpc.Code.FAILED_PRECONDITION` if `depth < i1`
   *
   * @generated from enum value: OP_ROLL = 9;
   */
  OP_ROLL = 9,

  /**
   * Push `env[stack(0)]` to the stack. If the value doesn't exist in
   * the environment, `null` is pushed.
   *
   * Stack signature: `[-1, 1]`
   *
   * @generated from enum value: OP_GETVAR = 10;
   */
  OP_GETVAR = 10,

  /**
   * Perform `env[stack(0)] = stack(-1)`.
   *
   * Stack signature: `[-2]`
   *
   * @generated from enum value: OP_SETVAR = 11;
   */
  OP_SETVAR = 11,

  /**
   * Remove `env[stack(0)]` from the environment. If there is no such
   * environment variable, this is a no-op.
   *
   * Stack signature: `[-1]`
   *
   * @generated from enum value: OP_CLEARVAR = 12;
   */
  OP_CLEARVAR = 12,

  /**
   * Determine if `env[stack(0)]` exists. Pushes boolean TRUE or FALSE.
   *
   * Stack signature: `[-1, 1]`
   *
   * @generated from enum value: OP_CHECKVAR = 13;
   */
  OP_CHECKVAR = 13,

  /**
   * Computes the Boolean equivalent of the value atop the stack. If the result
   * is equivalent to `i1`,
   * the next instruction in the code segment is skipped. If the
   * result is not, the next instruction in the code segment is executed.
   * The next instruction is expected to be a JMP to an "else" branch.
   *
   * `i1`: If `i1 == 0`, the branch is taken if true. If `i1 != 0`, the branch
   * is taken if false.
   *
   * Stack signature: `[-1]`
   *
   * @generated from enum value: OP_TEST = 14;
   */
  OP_TEST = 14,

  /**
   * Jump instruction. Moves the instruction pointer to another index within the
   * currently-executing code segment.
   *
   * `i1`: Position in function to jump to.
   *
   * @generated from enum value: OP_JMP = 15;
   */
  OP_JMP = 15,

  /**
   * Push an environment onto the call stack.
   *
   * @generated from enum value: OP_ENVPUSH = 16;
   */
  OP_ENVPUSH = 16,

  /**
   * Pop an environment off the call stack.
   *
   * @generated from enum value: OP_ENVPOP = 17;
   */
  OP_ENVPOP = 17,

  /**
   * Calls the function at `stack(0)` with `stack(-1)` arguments ranging
   * from `stack(-2)` to `stack(-2 - stack(-1) - 1)`. If the function
   * returns with success, leaves the return value on the stack.
   *
   * `i1`: If `i1 == 1`, this call is treated as a `try`. `result` and `error`
   * are pushed to the stack, with `error` being `null` if there was no error.
   * and `result` being `null` if an error was caught.
   *
   * Stack signature: `[-(stack(-1) + 2), (i1 == 1) ? 2 : 1]`
   *
   * @generated from enum value: OP_CALL = 18;
   */
  OP_CALL = 18,

  /**
   * Return to the previous function in the call stack, with the instruction
   * pointer advanced past `OP_CALL`. The value of `stack(0)` will be returned
   * and pushed at the call site as a successful result.
   *
   * Stack signature: `[-1]`
   *
   * @generated from enum value: OP_RETURN = 19;
   */
  OP_RETURN = 19,

  /**
   * Throw an error. `stack(0)` must be a `google.rpc.Status`. The stack is
   * unwound until a frame with an error handler is reached, and control
   * is returned to that frame. 
   *
   * @generated from enum value: OP_THROW = 20;
   */
  OP_THROW = 20,

  /**
   * Execute `OP(stack(0), stack(-1))`, pushing the result.
   *
   * Stack signature: `[-2, 1]`
   *
   * @generated from enum value: OP_BINOP = 21;
   */
  OP_BINOP = 21,

  /**
   * Execute `OP(stack(0))`, pushing the result.
   *
   * Stack signature: `[-1, 1]`
   *
   * @generated from enum value: OP_UNOP = 22;
   */
  OP_UNOP = 22,

  /**
   * Create a new message. `stack(0)` must be a string containing the fully
   * qualified Protobuf type of the message to create. `stack(-1)` is the number
   * of key-value pairs to be used in the initial construction. `stack(-2)` thru
   * `stack(-2 - 2*stack(-1))` is a sequence of `stack(1)` key-value pairs to
   * be assigned as the initial value of the newly constructed message.
   *
   * @generated from enum value: OP_NEWMESSAGE = 23;
   */
  OP_NEWMESSAGE = 23,

  /**
   * Create a new map. `stack(0)` is the number of entries in the map.
   * `stack(-1)` thru
   * `stack(-1 - 2*stack(0))` is a sequence of `stack(0)` key-value pairs
   * to be assigned to the newly constructed map.
   *
   * @generated from enum value: OP_NEWMAP = 24;
   */
  OP_NEWMAP = 24,

  /**
   * Create a new list. `stack(0)` is a number indicating the length of the
   * list. `stack(-1)` thru `stack(-1 - stack(0))` is a sequence of elements
   * to initialize the list.
   *
   * @generated from enum value: OP_NEWLIST = 25;
   */
  OP_NEWLIST = 25,

  /**
   * Create a closure. `stack(0)` is a string naming the function body to be
   * called. `stack(-1)` is either `null` or a `Map<string, value>`. If
   * it is a map, it is treated as the captured local environment, with
   * keys naming variables and values as the initial values.
   *
   * @generated from enum value: OP_NEWCLOSURE = 26;
   */
  OP_NEWCLOSURE = 26,

  /**
   * Persist the current state, which should be a "known good" state, to the
   * controller responsible for this workflow run.
   * Execution is always suspended until the responsible
   * controller confirms that the checkpoint has been persisted.
   *
   * @generated from enum value: OP_CHECKPOINT = 27;
   */
  OP_CHECKPOINT = 27,

  /**
   * Execute an action (driver-defined, usually an RPC call) leaving a
   * `google.rpc.Status` object at the top of the stack 
   *
   * @generated from enum value: OP_ACTION = 28;
   */
  OP_ACTION = 28,
}
// Retrieve enum metadata with: proto3.getEnumType(Opcode)
proto3.util.setEnumType(Opcode, "workflowasm.lang.v1.Opcode", [
  { no: 0, name: "OP_NOOP" },
  { no: 1, name: "OP_PUSHNULL" },
  { no: 2, name: "OP_PUSHINT" },
  { no: 3, name: "OP_PUSHDEPTH" },
  { no: 4, name: "OP_PUSHK" },
  { no: 5, name: "OP_PUSHINDEX" },
  { no: 6, name: "OP_PUSHENV" },
  { no: 7, name: "OP_DUP" },
  { no: 8, name: "OP_POP" },
  { no: 9, name: "OP_ROLL" },
  { no: 10, name: "OP_GETVAR" },
  { no: 11, name: "OP_SETVAR" },
  { no: 12, name: "OP_CLEARVAR" },
  { no: 13, name: "OP_CHECKVAR" },
  { no: 14, name: "OP_TEST" },
  { no: 15, name: "OP_JMP" },
  { no: 16, name: "OP_ENVPUSH" },
  { no: 17, name: "OP_ENVPOP" },
  { no: 18, name: "OP_CALL" },
  { no: 19, name: "OP_RETURN" },
  { no: 20, name: "OP_THROW" },
  { no: 21, name: "OP_BINOP" },
  { no: 22, name: "OP_UNOP" },
  { no: 23, name: "OP_NEWMESSAGE" },
  { no: 24, name: "OP_NEWMAP" },
  { no: 25, name: "OP_NEWLIST" },
  { no: 26, name: "OP_NEWCLOSURE" },
  { no: 27, name: "OP_CHECKPOINT" },
  { no: 28, name: "OP_ACTION" },
]);

/**
 * Binary operators
 *
 * @generated from enum workflowasm.lang.v1.Binop
 */
export enum Binop {
  /**
   * @generated from enum value: BINOP_ADD = 0;
   */
  ADD = 0,

  /**
   * @generated from enum value: BINOP_SUB = 1;
   */
  SUB = 1,

  /**
   * @generated from enum value: BINOP_MUL = 2;
   */
  MUL = 2,

  /**
   * @generated from enum value: BINOP_DIV = 3;
   */
  DIV = 3,

  /**
   * @generated from enum value: BINOP_MOD = 4;
   */
  MOD = 4,

  /**
   * @generated from enum value: BINOP_POW = 5;
   */
  POW = 5,

  /**
   * @generated from enum value: BINOP_AND = 6;
   */
  AND = 6,

  /**
   * @generated from enum value: BINOP_OR = 7;
   */
  OR = 7,

  /**
   * @generated from enum value: BINOP_EQ = 8;
   */
  EQ = 8,

  /**
   * @generated from enum value: BINOP_LT = 9;
   */
  LT = 9,

  /**
   * @generated from enum value: BINOP_LE = 10;
   */
  LE = 10,

  /**
   * @generated from enum value: BINOP_NULLISH_COALESCE = 11;
   */
  NULLISH_COALESCE = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(Binop)
proto3.util.setEnumType(Binop, "workflowasm.lang.v1.Binop", [
  { no: 0, name: "BINOP_ADD" },
  { no: 1, name: "BINOP_SUB" },
  { no: 2, name: "BINOP_MUL" },
  { no: 3, name: "BINOP_DIV" },
  { no: 4, name: "BINOP_MOD" },
  { no: 5, name: "BINOP_POW" },
  { no: 6, name: "BINOP_AND" },
  { no: 7, name: "BINOP_OR" },
  { no: 8, name: "BINOP_EQ" },
  { no: 9, name: "BINOP_LT" },
  { no: 10, name: "BINOP_LE" },
  { no: 11, name: "BINOP_NULLISH_COALESCE" },
]);

/**
 * Unary operators
 *
 * @generated from enum workflowasm.lang.v1.Unop
 */
export enum Unop {
  /**
   * @generated from enum value: UNOP_MINUS = 0;
   */
  MINUS = 0,

  /**
   * @generated from enum value: UNOP_NOT = 1;
   */
  NOT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Unop)
proto3.util.setEnumType(Unop, "workflowasm.lang.v1.Unop", [
  { no: 0, name: "UNOP_MINUS" },
  { no: 1, name: "UNOP_NOT" },
]);

/**
 * A single instruction in a WorkflowASM program.
 *
 * @generated from message workflowasm.lang.v1.Instruction
 */
export class Instruction extends Message<Instruction> {
  /**
   * Opcode for the instruction
   *
   * @generated from field: workflowasm.lang.v1.Opcode opcode = 1;
   */
  opcode = Opcode.OP_NOOP;

  /**
   * Integer parameter 1. Interpretation of this parameter depends on the
   * opcode.
   *
   * @generated from field: int32 i1 = 2;
   */
  i1 = 0;

  constructor(data?: PartialMessage<Instruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "workflowasm.lang.v1.Instruction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "opcode", kind: "enum", T: proto3.getEnumType(Opcode) },
    { no: 2, name: "i1", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Instruction {
    return new Instruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Instruction {
    return new Instruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Instruction {
    return new Instruction().fromJsonString(jsonString, options);
  }

  static equals(a: Instruction | PlainMessage<Instruction> | undefined, b: Instruction | PlainMessage<Instruction> | undefined): boolean {
    return proto3.util.equals(Instruction, a, b);
  }
}

